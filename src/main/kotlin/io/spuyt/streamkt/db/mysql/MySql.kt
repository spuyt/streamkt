package io.spuyt.streamkt.db.mysql

import io.spuyt.streamkt.consumer.ConsumerState
import io.spuyt.streamkt.db.StreamDatabase
import io.spuyt.streamkt.event.EventMessage
import org.jetbrains.exposed.sql.*
import org.jetbrains.exposed.sql.transactions.transaction
import org.jetbrains.exposed.sql.vendors.PostgreSQLDialect
import org.jetbrains.exposed.sql.vendors.currentDialect

/*

EventMessages need to be saved with the following fields:

Table: events
  id                    : Long    -- generated by MySQL
  eventId               : String
  creationTimeUnixSec   : Long
  eventTimeUnixSec      : Long
  deviceId              : String
  locationId            : String
  appVersion            : String
  eventType             : String
  eventVersion          : String
  payloadJson           : String


ConsumerState need to be saved with the following fields:

Table: consumerStates
  id            : Long    -- generated by MySQL
  consumerId    : String
  cursor        : Long

*/



object MySql : StreamDatabase {

    var createEventsTableQuery: String =
            """
                CREATE TABLE IF NOT EXISTS events (
                    id BIGINT AUTO_INCREMENT PRIMARY KEY,
                    eventId VARCHAR(255) NOT NULL,
                    creationTimeUnixSec BIGINT,
                    eventTimeUnixSec BIGINT,
                    deviceId VARCHAR(255) NOT NULL,
                    locationId VARCHAR(255) NOT NULL,
                    appVersion VARCHAR(255) NOT NULL,
                    eventType VARCHAR(255) NOT NULL,
                    eventVersion VARCHAR(255) NOT NULL,
                    payloadJson TEXT
                );
            """.trimIndent()

    var createConsumerStatesTableQuery: String =
            """
                CREATE TABLE IF NOT EXISTS consumer_states (
                    id BIGINT AUTO_INCREMENT PRIMARY KEY,
                    consumerId VARCHAR(255) NOT NULL,
                    cursor BIGINT
                );
            """.trimIndent()

    object Events : Table() {
        val id = long("id").autoIncrement() // Column<Long>
        override val primaryKey = PrimaryKey(id) // name is optional here
        val eventId = varchar("event_id", length = 255).uniqueIndex("event_id") // Column<String>, needs to be unique
        val creationTimeUnixSec = long("creation_time_unix_sec") // Column<Long>
        val eventTimeUnixSec = long("event_time_unix_sec") // Column<Long>
        val deviceId = varchar("device_id", length = 255) // Column<String>
        val locationId = varchar("location_id", length = 255) // Column<String>
        val appVersion = varchar("app_version", length = 255) // Column<String>
        val eventType = varchar("event_type", length = 255) // Column<String>
        val eventVersion = varchar("event_version", length = 255) // Column<String>
        val payloadJson = text("payload_json") // Column<String>
    }

    object ConsumerStates : Table() {
        val id = long("id").autoIncrement() // Column<Long>
        override val primaryKey = PrimaryKey(id) // name is optional here
        val consumerId = varchar("consumer_id", length = 255) // Column<String>
        val cursor = long("cursor") // Column<Long>
    }

    fun connectDebug() {
        Database.connect("jdbc:mysql://127.0.0.1:33060/streamkt", "com.mysql.cj.jdbc.Driver", "root", "streamkt-dev-pw")
        transaction {
            addLogger(StdOutSqlLogger)
            createTables()
        }
    }

    fun connectPostgreSQL(url: String, username: String, password: String) {
        Database.connect("jdbc:postgresql://"+url, "org.postgresql.Driver", username, password)
        transaction {
            addLogger(StdOutSqlLogger)
            createTables()
        }
    }

    fun createTables() {
        SchemaUtils.create(Events)
        SchemaUtils.create(ConsumerStates)
    }



    override suspend fun insert(event: EventMessage): Long {
        var id = 0L
        transaction {
            //addLogger(StdOutSqlLogger)
            id = Events.insert {
                it[eventId] = event.eventId
                it[creationTimeUnixSec] = event.creationTimeUnixSec
                it[eventTimeUnixSec] = event.eventTimeUnixSec
                it[deviceId] = event.deviceId
                it[locationId] = event.locationId
                it[appVersion] = event.appVersion
                it[eventType] = event.eventType
                it[eventVersion] = event.eventVersion
                it[payloadJson] = event.payloadJson
            } get Events.id
        }
        return id
    }

    override suspend fun getAfter(cursor: Long, batchSize: Int): List<EventMessage> {
        val events = mutableListOf<EventMessage>()
        transaction {
            //addLogger(StdOutSqlLogger)
            Events.select { Events.id.greater(cursor) }.orderBy(Events.id, SortOrder.ASC).forEach {
                val event = EventMessage(
                        it[Events.id],
                        it[Events.eventId],
                        it[Events.creationTimeUnixSec],
                        it[Events.eventTimeUnixSec],
                        it[Events.deviceId],
                        it[Events.locationId],
                        it[Events.appVersion],
                        it[Events.eventType],
                        it[Events.eventVersion],
                        it[Events.payloadJson]
                )
                events.add(event)
            }
        }
        return events.toList()
    }

    override suspend fun getAfterSelection(cursor: Long, eventTypes: List<String>, eventVersions: List<String>, batchSize: Int): List<EventMessage> {
        val events = mutableListOf<EventMessage>()
        transaction {
            //addLogger(StdOutSqlLogger)
            Events.select {
                Events.id.greater(cursor) and
                        Events.eventType.inList(eventTypes) and
                        Events.eventVersion.inList(eventVersions)
            }.orderBy(Events.id, SortOrder.ASC).forEach {
                val event = EventMessage(
                        it[Events.id],
                        it[Events.eventId],
                        it[Events.creationTimeUnixSec],
                        it[Events.eventTimeUnixSec],
                        it[Events.deviceId],
                        it[Events.locationId],
                        it[Events.appVersion],
                        it[Events.eventType],
                        it[Events.eventVersion],
                        it[Events.payloadJson]
                )
                events.add(event)
            }
        }
        return events.toList()
    }

    override suspend fun getCurrentCursor(): Long {
        var cursor: Long = 0L
        transaction {
            val row = Events.selectAll().orderBy(Events.id, SortOrder.DESC).singleOrNull()
            row?.let {
                cursor = row[Events.id]
            }
        }
        return cursor
    }

    override suspend fun getConsumerState(consumerId: String): ConsumerState {
        var cs: ConsumerState = ConsumerState(consumerId, 0L)
        transaction {
            //addLogger(StdOutSqlLogger)
            val row = ConsumerStates.select { ConsumerStates.consumerId.eq(consumerId) }.singleOrNull()
            row?.let {
                cs = ConsumerState(
                        row[ConsumerStates.consumerId],
                        row[ConsumerStates.cursor]
                )
            }
        }
        return cs
    }

    override suspend fun saveConsumerState(consumerState: ConsumerState): Long {
        var id = 0L
        transaction {
            //addLogger(StdOutSqlLogger)
            id = ConsumerStates.insert {
                it[consumerId] = consumerState.consumerId
                it[cursor] = consumerState.cursor
            } get ConsumerStates.id
        }
        return id
    }

}