package io.spuyt.streamkt.db.mysql

import io.spuyt.streamkt.consumer.ConsumerState
import io.spuyt.streamkt.db.StreamDatabase
import io.spuyt.streamkt.event.EventMessage
import org.jetbrains.exposed.sql.*
import org.jetbrains.exposed.sql.transactions.transaction
import java.lang.Exception


/*

EventMessages need to be saved with the following fields:

Table: events
  id                    : Long    -- generated by MySQL
  eventId               : String
  creationTimeUnixSec   : Long
  eventTimeUnixSec      : Long
  deviceId              : String
  locationId            : String
  appVersion            : String
  eventType             : String
  eventVersion          : String
  payloadJson           : String


ConsumerState need to be saved with the following fields:

Table: consumerStates
  id            : Long    -- generated by MySQL
  consumerId    : String
  cursor        : Long

*/



object MySql : StreamDatabase {

    var createEventsTableQuery: String =
            """
                CREATE TABLE IF NOT EXISTS events (
                    id BIGINT AUTO_INCREMENT PRIMARY KEY,
                    eventId VARCHAR(255) NOT NULL,
                    creationTimeUnixSec BIGINT,
                    eventTimeUnixSec BIGINT,
                    deviceId VARCHAR(255) NOT NULL,
                    locationId VARCHAR(255) NOT NULL,
                    appVersion VARCHAR(255) NOT NULL,
                    eventType VARCHAR(255) NOT NULL,
                    eventVersion VARCHAR(255) NOT NULL,
                    payloadJson TEXT
                );
            """.trimIndent()

    var createConsumerStatesTableQuery: String =
            """
                CREATE TABLE IF NOT EXISTS consumer_states (
                    id BIGINT AUTO_INCREMENT PRIMARY KEY,
                    consumerId VARCHAR(255) NOT NULL,
                    cursor BIGINT
                );
            """.trimIndent()

    object Events : Table() {
        val id = long("id").autoIncrement() // Column<Long>
        override val primaryKey = PrimaryKey(id) // name is optional here
        val eventId = varchar("event_id", length = 255).uniqueIndex("event_id") // Column<String>, needs to be unique
        val creationTimeUnixSec = long("creation_time_unix_sec") // Column<Long>
        val eventTimeUnixSec = long("event_time_unix_sec") // Column<Long>
        val deviceId = varchar("device_id", length = 255) // Column<String>
        val locationId = varchar("location_id", length = 255) // Column<String>
        val appVersion = varchar("app_version", length = 255) // Column<String>
        val eventType = varchar("event_type", length = 255) // Column<String>
        val eventVersion = varchar("event_version", length = 255) // Column<String>
        val payloadJson = text("payload_json") // Column<String>
    }

    object ConsumerStates : Table() {
        val id = long("id").autoIncrement() // Column<Long>
        override val primaryKey = PrimaryKey(id) // name is optional here
        val consumerId = varchar("consumer_id", length = 255) // Column<String>
        val cursor = long("cursor") // Column<Long>
    }

    fun connectDebug() {
        Database.connect("jdbc:mysql://127.0.0.1:33060/streamkt", "com.mysql.jdbc.Driver", "root", "streamkt-dev-pw")
        transaction {
            addLogger(StdOutSqlLogger)
            createTables()
        }
    }

    fun connect(url: String, port: String, username: String, password: String) {

    }

    fun createTables() {
        SchemaUtils.create(Events)
        SchemaUtils.create(ConsumerStates)
    }



    override suspend fun insert(event: EventMessage): Long {
        val id = Events.insert {
            it[eventId] = event.eventId
            it[creationTimeUnixSec] = event.creationTimeUnixSec
            it[eventTimeUnixSec] = event.eventTimeUnixSec
            it[deviceId] = event.deviceId
            it[locationId] = event.locationId
            it[appVersion] = event.appVersion
            it[eventType] = event.eventType
            it[eventVersion] = event.eventVersion
            it[payloadJson] = event.payloadJson
        } get Events.id
        return id
    }

    override suspend fun getAfter(cursor: Long, batchSize: Int): List<EventMessage> {
        val events = mutableListOf<EventMessage>()
        Events.select { Events.id.greater(cursor) }.forEach {
            val event = EventMessage(
                it[Events.id],
                it[Events.eventId],
                it[Events.creationTimeUnixSec],
                it[Events.eventTimeUnixSec],
                it[Events.deviceId],
                it[Events.locationId],
                it[Events.appVersion],
                it[Events.eventType],
                it[Events.eventVersion],
                it[Events.payloadJson]
            )
            events.add(event)
        }
        return events.toList()
    }

    override suspend fun getAfterSelection(cursor: Long, eventTypes: List<String>, eventVersions: List<String>, batchSize: Int): List<EventMessage> {
        val events = mutableListOf<EventMessage>()
        Events.select {
            Events.id.greater(cursor) and
            Events.eventType.inList(eventTypes) and
            Events.eventVersion.inList(eventVersions)
        }.forEach {
            val event = EventMessage(
                    it[Events.id],
                    it[Events.eventId],
                    it[Events.creationTimeUnixSec],
                    it[Events.eventTimeUnixSec],
                    it[Events.deviceId],
                    it[Events.locationId],
                    it[Events.appVersion],
                    it[Events.eventType],
                    it[Events.eventVersion],
                    it[Events.payloadJson]
            )
            events.add(event)
        }
        return events.toList()
    }

    override suspend fun getConsumerState(consumerId: String): ConsumerState {
        ConsumerStates.select { ConsumerStates.consumerId.eq(consumerId) }.forEach { // TODO dont know how to get only one
            val cs = ConsumerState(
                    it[ConsumerStates.consumerId],
                    it[ConsumerStates.cursor]
            )
            return cs
        }
        throw Exception("consumer state not found in the database")
    }

    override suspend fun saveConsumerState(consumerState: ConsumerState): Long {
        val id = ConsumerStates.insert {
            it[consumerId] = consumerState.consumerId
            it[cursor] = consumerState.cursor
        } get ConsumerStates.id
        return id
    }


}